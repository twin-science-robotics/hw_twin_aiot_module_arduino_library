/* 
  Harf

  Bu örnek, Twin AIoT modülündeki Led Matrix'de istenen harfi gösterir.

  https://github.com/twin-science-robotics/hw_twin_aiot_module_arduino_library

  15 Ağustos 2025
  Twin Science & Robotics
*/

// 8x8'lik Led Matrix'i süren shift registerların bağlı bulundukları pinler
#define latchPin 34
#define clockPin 47
#define dataPin 48

// Harf yapısını tanımla
struct LEDMatrixharf {
  char harf;  // harfin kendisi
  uint8_t patern[8]; //  harfin paterni
};

// Her harf için belirli bir patern vardır, bu patern bilgisine göre hangi ledin yanıp yanmayacağına karar verilir.
const LEDMatrixharf ledMatrixharfler[] = {
{ 'A', {0x18, 0x24, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00} },
{ 'B', {0x7C, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x7C, 0x00} },
{ 'C', {0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00} },
{ 'D', {0x78, 0x44, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00} },
{ 'E', {0x7E, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x7E, 0x00} },
{ 'F', {0x7E, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x00} },
{ 'G', {0x3C, 0x42, 0x40, 0x40, 0x46, 0x42, 0x3C, 0x00} },
{ 'H', {0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00} },
{ 'I', {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00} },
{ 'J', {0x7E, 0x02, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00} },
{ 'K', {0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00} },
{ 'L', {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00} },
{ 'M', {0x42, 0x66, 0x5A, 0x42, 0x42, 0x42, 0x42, 0x00} },
{ 'N', {0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x00} },
{ 'O', {0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00} },
{ 'P', {0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00} },
{ 'Q', {0x3C, 0x42, 0x42, 0x42, 0x4A, 0x46, 0x3C, 0x00} },
{ 'R', {0x7C, 0x42, 0x42, 0x7C, 0x48, 0x44, 0x42, 0x00} },
{ 'S', {0x3C, 0x42, 0x40, 0x3C, 0x02, 0x42, 0x3C, 0x00} },
{ 'T', {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00} },
{ 'U', {0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00} },
{ 'V', {0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00} },
{ 'W', {0x42, 0x42, 0x42, 0x42, 0x5A, 0x66, 0x42, 0x00} },
{ 'X', {0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42, 0x00} },
{ 'Y', {0x42, 0x42, 0x42, 0x24, 0x18, 0x18, 0x18, 0x00} },
{ 'Z', {0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00} },
{ ' ', {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} }
};

const size_t harfsayisi = sizeof(ledMatrixharfler) / sizeof(LEDMatrixharf); // Tanımladığımız toplam harf sayısı

// reset tuşuna bastığınızda veya kartı açtığınızda kurulum işlevi (setup) bir kez çalışır
void setup() {
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
}

// insan gözünün hareketli görüntüleri akıcı şekilde algılaması için 24 fps (frame per second, saniyedeki çerçeve hızı) yeterlidir
// göstereceğimiz harf için led matrisi doğru hızda yenilemek gerekir, bu yüzden döngü (loop) fonksiyonu tekrar tekrar çalışır
void loop() {
  harfi_goster('A');  // seçili harfi göster, Örnek :'A'
  delay(10);          // ekran yenileme hızını bu bekleme süresiyle ayarlayabilirsiniz, bekleme süresini artırdıkça -> matrisi yenileme hızını düşürdükçe Led matrix'deki ledlerin titrediğini gözlemleyebilirsiniz
}

// Led matrix'te gösterilecek harf için her satırdaki ledleri sırayla çok hızlı şekilde yakar
void harfi_goster(char c){

  const uint8_t* pattern = paterniAl(c);
  
  for (int row = 0; row < 8; row++) {
        uint8_t patternRow = pattern[row];
        uint8_t reversedPattern = reverseBits(patternRow);
        uint8_t rowData = (1 << row);
        uint8_t colData = ~reversedPattern;     
        shiftOutAll(colData, rowData);
        delay(1);  
        shiftOutAll(0x00, 0x00);
      }
}

// Her harf için gerekli patern alınır
const uint8_t* paterniAl(char c) {

  for (size_t i = 0; i < harfsayisi; i++) {
    if (ledMatrixharfler[i].harf == c) {
      return ledMatrixharfler[i].patern;
    }
  }
  return ledMatrixharfler[harfsayisi - 1].patern;
}


// Her ledin yanma durumunu ayarla
uint8_t reverseBits(uint8_t b) {
  b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
  b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
  b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
  return b;
}


// Led matrix'i çalıştır
void shiftOutAll(uint8_t colData, uint8_t rowData) {
  digitalWrite(latchPin, LOW);
  shiftOut(dataPin, clockPin, MSBFIRST, colData);
  shiftOut(dataPin, clockPin, MSBFIRST, rowData);
  digitalWrite(latchPin, HIGH);
}

